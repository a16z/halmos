// SPDX-License-Identifier: AGPL-3.0
pragma solidity >=0.8.0 <0.9.0;

import "forge-std/Test.sol";
import {SymTest} from "halmos-cheatcodes/SymTest.sol";

// Functional correctness test for the system contract bytecode in https://eips.ethereum.org/EIPS/eip-7002

/// @custom:halmos --storage-layout generic
contract EIP7002Test is SymTest, Test {
    address constant WITHDRAWAL_REQUEST_PREDEPLOY_ADDRESS = address(0x00A3ca265EBcb825B45F985A16CEFB49958cE017);
    address constant SYSTEM_ADDRESS = address(0xffffFFFfFFffffffffffffffFfFFFfffFFFfFFfE);

    uint constant EXCESS_WITHDRAWAL_REQUESTS_STORAGE_SLOT = 0;
    uint constant WITHDRAWAL_REQUEST_COUNT_STORAGE_SLOT = 1;
    uint constant WITHDRAWAL_REQUEST_QUEUE_HEAD_STORAGE_SLOT = 2;
    uint constant WITHDRAWAL_REQUEST_QUEUE_TAIL_STORAGE_SLOT = 3;
    uint constant WITHDRAWAL_REQUEST_QUEUE_STORAGE_OFFSET = 4;
    uint constant MAX_WITHDRAWAL_REQUESTS_PER_BLOCK = 16;
    uint constant TARGET_WITHDRAWAL_REQUESTS_PER_BLOCK = 2;
    uint constant MIN_WITHDRAWAL_REQUEST_FEE = 1;
    uint constant WITHDRAWAL_REQUEST_FEE_UPDATE_FRACTION = 17;

    // TODO: figure out the meaning of this magic value
    uint constant EXCESS_INHIBITOR = 1181;

    struct State {
        uint balance;
        uint excess;
        uint count;
        uint queueHeadIndex;
        uint queueTailIndex;
        // TODO: add untouched slots
    }

    State initState;

    function _setUpBlock() internal {
        vm.fee(svm.createUint256("block.basefee"));
        vm.chainId(svm.createUint256("block.chainid"));
        vm.coinbase(svm.createAddress("block.coinbase"));
        vm.difficulty(svm.createUint256("block.difficulty"));
        vm.warp(svm.createUint256("block.timestamp"));
        vm.roll(svm.createUint256("block.number"));
    }

    function _getState() internal view returns (State memory) {
        uint balance = WITHDRAWAL_REQUEST_PREDEPLOY_ADDRESS.balance;

        uint excess = uint(vm.load(WITHDRAWAL_REQUEST_PREDEPLOY_ADDRESS, bytes32(EXCESS_WITHDRAWAL_REQUESTS_STORAGE_SLOT)));
        uint count = uint(vm.load(WITHDRAWAL_REQUEST_PREDEPLOY_ADDRESS, bytes32(WITHDRAWAL_REQUEST_COUNT_STORAGE_SLOT)));

        uint queueHeadIndex = uint(vm.load(WITHDRAWAL_REQUEST_PREDEPLOY_ADDRESS, bytes32(WITHDRAWAL_REQUEST_QUEUE_HEAD_STORAGE_SLOT)));
        uint queueTailIndex = uint(vm.load(WITHDRAWAL_REQUEST_PREDEPLOY_ADDRESS, bytes32(WITHDRAWAL_REQUEST_QUEUE_TAIL_STORAGE_SLOT)));

        return State(balance, excess, count, queueHeadIndex, queueTailIndex);
    }

    function _getQueueItem(uint slot) internal view returns (bytes memory) {
        bytes32 item0 = vm.load(WITHDRAWAL_REQUEST_PREDEPLOY_ADDRESS, bytes32(slot));
        bytes32 item1 = vm.load(WITHDRAWAL_REQUEST_PREDEPLOY_ADDRESS, bytes32(slot + 1));
        bytes32 item2 = vm.load(WITHDRAWAL_REQUEST_PREDEPLOY_ADDRESS, bytes32(slot + 2));
        return bytes.concat(item0, item1, item2);
    }

    function _getSource(bytes memory item) internal view returns (address) {
        return address(uint160(bytes20(this.slice(item, 12, 32))));
    }

    function _getPubkey(bytes memory item) internal view returns (bytes memory) {
        return this.slice(item, 32, 80);
    }

    function _getAmountLE(bytes memory item) internal view returns (bytes8) {
        return bytes8(this.slice(item, 80, 88));
    }

    function _getAmountBE(bytes memory item) internal view returns (bytes8) {
        bytes8 amountLE = _getAmountLE(item);
        return bytes8(bytes.concat(amountLE[7], amountLE[6], amountLE[5], amountLE[4], amountLE[3], amountLE[2], amountLE[1], amountLE[0]));
    }

    function setUp() public {
        // set the bytecode generated by `geas src/withdrawals/main.eas` in lightclient/sys-asm at commit 0ff405f3f682e3f232bbb84f0ff1ff2ddda837dd
        vm.etch(WITHDRAWAL_REQUEST_PREDEPLOY_ADDRESS, hex"3373fffffffffffffffffffffffffffffffffffffffe1460a0573615156028575f545f5260205ff35b36603814156101ab5760115f54600182026001905f5b5f82111560595781019083028483029004916001019190603e565b9093900434106101ab57600154600101600155600354806003026004013381556001015f35815560010160203590553360601b5f5260385f601437604c5fa0600101600355005b6003546002548082038060101160b4575060105b5f5b8181146101585780604c02838201600302600401805490600101805490600101549160601b83528260140152807fffffffffffffffffffffffffffffffff0000000000000000000000000000000016826034015260401c906044018160381c81600701538160301c81600601538160281c81600501538160201c81600401538160181c81600301538160101c81600201538160081c81600101535360010160b6565b910180921461016a5790600255610175565b90505f6002555f6003555b5f548061049d141561018457505f5b6001546002828201116101995750505f61019f565b01600290035b5f555f600155604c025ff35b5f5ffd");

        // set symbolic storage and balance
        svm.enableSymbolicStorage(WITHDRAWAL_REQUEST_PREDEPLOY_ADDRESS);
        vm.deal(WITHDRAWAL_REQUEST_PREDEPLOY_ADDRESS, svm.createUint(96, "WITHDRAWAL_REQUEST_PREDEPLOY_ADDRESS.balance"));

        // set symbolic block info
        _setUpBlock();

        // record initial state
        initState = _getState();

        // assume valid initial state
        // TODO: compute the max value based on practical fee limit
        vm.assume(initState.excess < 2**64);
        vm.assume(initState.count < 2**64);
        vm.assume(initState.queueHeadIndex <= initState.queueTailIndex);
        vm.assume(initState.queueTailIndex < 2**64);
    }

    /// @custom:halmos --loop 16
    function check_user_operation(address caller, uint value) public {
        // user operation
        vm.assume(caller != SYSTEM_ADDRESS);

        // set symbolic balance for caller
        uint callerBalance = svm.createUint(96, "caller.balance");
        vm.deal(caller, callerBalance);

        // TODO: use multiple bytes sizes feature
        bytes memory data;
        if (svm.createBool("datasize0")) {
            data = hex"";
        } else if (svm.createBool("datasize56")) {
            data = svm.createBytes(56, "data");
        } else {
            data = svm.createBytes(1024, "data");
        }

        // call WITHDRAWAL_REQUEST_PREDEPLOY_ADDRESS
        vm.prank(caller);
        (bool success, bytes memory retdata) = WITHDRAWAL_REQUEST_PREDEPLOY_ADDRESS.call{value: value}(data);

        // record the updated state
        State memory newState = _getState();

        if (data.length == 0) {
            assertTrue(success);
            assertEq(uint(bytes32(retdata)), initState.excess);
            // TODO: assertEq(initState, newState);
        } else if (data.length == 56) {
            if (success) {
                // ensure count has increased
                assertEq(newState.count, initState.count + 1);

                // ensure new queue element
                uint queueTailSlot = WITHDRAWAL_REQUEST_QUEUE_STORAGE_OFFSET + initState.queueTailIndex * 3;
                assertEq(_getQueueItem(queueTailSlot), bytes.concat(bytes32(uint(uint160(caller))), data, bytes8(0)));

                // TODO: properties about fee calculation
            } else {
                // TODO: ensure revert only due to insufficient fees
            }
        } else {
            // ensure revert when calldatasize is neither 0 nor 56
            assertFalse(success);
        }
    }

    /// @custom:halmos --loop 17
    function check_system_operation(address caller, uint value) public {
        // system operation
        vm.assume(caller == SYSTEM_ADDRESS);

        // set symbolic balance for caller
        uint callerBalance = svm.createUint(96, "caller.balance");
        vm.deal(caller, callerBalance);

        // TODO: arbitrary calldata sizes
        bytes memory data = svm.createBytes(1024, "data");

        // call WITHDRAWAL_REQUEST_PREDEPLOY_ADDRESS
        vm.prank(caller);
        (bool success, bytes memory retdata) = WITHDRAWAL_REQUEST_PREDEPLOY_ADDRESS.call{value: value}(data);

        // record the updated state
        State memory newState = _getState();

        //console.log("system");

        assertTrue(success);

        // ensure excess update
        // TODO: use max(..., 0) to handle the subtraction overflow
        if (initState.excess != EXCESS_INHIBITOR) {
            assertEq(newState.excess, initState.excess + initState.count - TARGET_WITHDRAWAL_REQUESTS_PER_BLOCK);
        } else {
            // TODO: figure out the purpose of this logic
            assertEq(newState.excess,                    initState.count - TARGET_WITHDRAWAL_REQUESTS_PER_BLOCK);
        }

        // ensure count reset
        assertEq(newState.count, 0);

        // TODO: ensure no overflow in the subtractions below
        uint oldQueueSize = initState.queueTailIndex - initState.queueHeadIndex;
        uint newQueueSize = newState.queueTailIndex - newState.queueHeadIndex;
        uint numDequeued = oldQueueSize - newQueueSize;

        // ensure queue pointer updates
        if (oldQueueSize <= MAX_WITHDRAWAL_REQUESTS_PER_BLOCK) {
            assertEq(newState.queueHeadIndex, 0);
            assertEq(newState.queueTailIndex, 0);
        } else {
            assertEq(newState.queueTailIndex, initState.queueTailIndex);
        }

        // ensure max withdrawals per block
        assertLe(numDequeued, MAX_WITHDRAWAL_REQUESTS_PER_BLOCK);

        // ensure retdata size
        assertEq(retdata.length, 76 * numDequeued);

        //console.log("numDequeued");
        //console.log(numDequeued);

        // check retdata
        for (uint i = 0; i < numDequeued; i++) {
            // TODO: to avoid slowdown as iteration progresses. use push/pop feature once available.
            if (svm.createBool("check-retdata")) {
                uint queueCurrSlot = WITHDRAWAL_REQUEST_QUEUE_STORAGE_OFFSET + (initState.queueHeadIndex + i) * 3;
                bytes memory queueCurrItem = _getQueueItem(queueCurrSlot);

                uint retOffset = 76 * i;
                // check source address
                // TODO: ensure invariant that all source addresses are valid (no dirty higher bits)
                assertEq(_getSource(queueCurrItem), address(uint160(bytes20(this.slice(retdata, retOffset + 0, retOffset + 20)))));

                // check validator pubkey
                assertEq(_getPubkey(queueCurrItem), this.slice(retdata, retOffset + 20, retOffset + 68));

                // ensure big-endian amount
                assertEq(_getAmountBE(queueCurrItem), bytes8(this.slice(retdata, retOffset + 68, retOffset + 76)));

                //console.log(i);
                //console.log("");
                return;
            }
        }
    }

    // helper
    function slice(bytes calldata data, uint start, uint end) external pure returns (bytes memory) {
        return data[start:end];
    }
}
